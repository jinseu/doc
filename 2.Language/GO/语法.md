## 语法

#### 基本语法

1. 布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。
2. `:=）`，用于明确表达同时进行变量声明和初始化的工作
3. 对于一个复数z = complex(x, y)，就可以通过Go语言内置函数real(z)获得该复数的实部，也就是x，通过imag(z)获得该复数的虚部，也就是y。
4. Go支持C语言风格的/* */块注释，也支持C＋＋风格的//行注释。 当然，行注释更通用，块注释主要用于针对包的详细说明或者屏蔽大块的代码。


### 数据类型

#### 字符串



**1. 不支持enum**

enum的定义可以采用下面的方式

```
const (    Sunday = iota    Monday    Tuesday    Wednesday    Thursday    Friday    Saturday    numberOfDays // 这个常量没有导出)
```

**2. 指针**

**3. 数组**

数组可以使用两种方式遍历，使用索引遍历或者使用`range`函数遍历。在使用`range`函数遍历时，返回`index, value`.

数组是一个值类型（value type）。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。

同理，在对map操作，对应的值为数组时也会有类似的问题。

```
    testMap := make(map[int] [3] int)
    testMap[1] = [3]int{3,3,3}
    kk, _ := testMap[1]
    kk[2] += 1
    fmt.Printf("%d\n", kk[2])   //4
    ww, _ := testMap[1]
    fmt.Printf("%d\n", ww[2])   //3
```**4. 切片**

1. 改变数组切片中的数据，对应的数组中的数组也会改变。
2. 可以根据数组切片创建新的数组切片，此时新的数组切片会分配新的内存空间。
3. append 函数可以用来为数组切片附加数据，返回值为新的数组切片。
4. 使用make函数创建数组切片的时候，可以指定数组的大小(len 函数可以查看)，以及数组的容量（cap函数可以查看)。**5. 字典****6. 通道****7. 结构体****8. 接口**


### 内置函数

**1. new函数和make函数的区别**

2. 