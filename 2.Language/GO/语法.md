## 语法

### 基本语法


#### 包

1. 代码是以包的形式组织在一起的
2. golang 在编译的时候会去`$GOPTAH`,`$GOROOT` 目录下查找相关的包，一般来说`$GOPTAH`目录下是第三方的包，`$GOROOT`则是golang的标准库。
3. 可以为每个工程设置不同的GOPATH，以保持源代码和依赖的隔离。
3. 每个包可以包含任意多个init 函数，这些函数都会在程序执行开始的时候被调用。

#### 常见问题

1. 布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。
2. `:=）`，用于明确表达同时进行变量声明和初始化的工作
3. 对于一个复数z = complex(x, y)，就可以通过Go语言内置函数real(z)获得该复数的实部，也就是x，通过imag(z)获得该复数的虚部，也就是y。
4. Go支持C语言风格的/* */块注释，也支持C＋＋风格的//行注释。 当然，行注释更通用，块注释主要用于针对包的详细说明或者屏蔽大块的代码。

#### 字符串

1. Golang的双引号和反引号都可用于表示一个常量字符串，不同在于：
 * 双引号用来创建可解析的字符串字面量(支持转义，但不能用来引用多行)
 * 反引号用来创建原生的字符串字面量，这些字符串可能由多行组成(不支持任何转义序列)，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式
2. 在strut中，可以使用字符串对变量打tag，然后使用reflect包获取对应的tag。
```
package main

import (
     "fmt"
    "reflect" // 这里引入reflect模块
)
type User struct {
    Name   string "user name" //这引号里面的就是tag
    Passwd string `user passsword`
}
func main() {
    user := &User{"chronos", "pass"}
    s := reflect.TypeOf(user).Elem() //通过反射获取type定义
    for i := 0; i < s.NumField(); i++ {
        fmt.Println(s.Field(i).Tag) //将tag输出出来
    }
}

> user name
> user passsword
```

#### 条件语句

1. 条件语句不需要使用括号将条件包含起来()；2. 无论语句体内有几条语句，花括号{}都是必须存在的；3. 左花括号{必须与if或者else处于同一行；4. 在if之后，条件语句之前，可以添加变量初始化语句，使用;间隔5. 在有返回值的函数中，不允许将“最终的”return语句包含在if...else...结构中

#### 选择语句

1. 左花括号{必须与switch处于同一行；2. 条件表达式不限制为常量或者整数；3. 单个case中，可以出现多个结果选项；4. 与C语言等规则相反，Go语言不需要用break来明确退出一个case；5. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；6. 可以不设定switch之后的条件表达式，在此种情况下，整个switch结构与多个if...else...的逻辑作用等同。

#### 循环语句

1. 左花括号{必须与for处于同一行。2. Go语言中的for循环与C语言一样，都允许在循环条件中定义和初始化变量，唯一的区别是，Go语言不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。3. Go语言的for循环同样支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环。在c/c++ 中break 语句只终止直接包围它的 do、for、switch 或 while 语句。
4. range关键字可以循序遍历一个数组`for k,v := range array`

#### 其他

1. defer语句的调用是遵照先进后出的原则，即最后一个defer语句将最先被执行。
2. defer执行的时机是，return子句已经执行，返回给调用上下文之前。

### 数据类型

1. byte实质上就是uint8类型
2. rune本质上是int32类型
3. string底层是用byte数组存的, 而且是不可变的，获取第i个元素地址的操作是无效的，例如`&s[i]`, 会导致编译时错误

```
func main() {
    s := "ha哈哈"
    r := []rune(s)
    fmt.Printf("%d %d\n", len(s), len(r)) // 8 4
    i := &r[3]
    fmt.Printf("%d\n", *i) // 21704
}
```


**1. 不支持enum**

enum的定义可以采用下面的方式

```
const (    Sunday = iota    Monday    Tuesday    Wednesday    Thursday    Friday    Saturday    numberOfDays // 这个常量没有导出)
```

**2. 指针**

**3. 数组**

数组可以使用两种方式遍历，使用索引遍历或者使用`range`函数遍历。在使用`range`函数遍历时，返回`index, value`.

数组是一个值类型（value type）。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。

同理，在对map操作，对应的值为数组时也会有类似的问题。

```
    testMap := make(map[int] [3] int)
    testMap[1] = [3]int{3,3,3}
    kk, _ := testMap[1]
    kk[2] += 1
    fmt.Printf("%d\n", kk[2])   //4
    ww, _ := testMap[1]
    fmt.Printf("%d\n", ww[2])   //3
```**4. 切片**

1. 改变数组切片中的数据，对应的数组中的数组也会改变。
2. 可以根据数组切片创建新的数组切片，此时新的数组切片会分配新的内存空间。
3. append 函数可以用来为数组切片附加数据，返回值为新的数组切片。
4. 使用make函数创建数组切片的时候，可以指定数组的大小(len 函数可以查看)，以及数组的容量（cap函数可以查看)。**5. 字典****6. 通道****7. 结构体****8. 接口**


### 内置函数

**1. new函数和make函数的区别**


### 异常处理

1. Go语言中并没有类似try catch 的异常处理机制。但是提供了panic和recover两个函数。
2. panic函数可以‘抛出’一个异常，事实上，并不是抛出，而是终止当前的执行流程，并从函数栈一次弹出，知道goroutine。
3. recover函数在异常时，可以获取目前当前的异常信息，并终止异常，使程序重新获得流程的控制权。但是需要注意的是，recover函数只能在defer语句中调用。

```
Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. 
```


## 类型

1. 在go语言中，可以给不是指针的任意类型添加方法。
 * 方法施加的目标（也就是“对象”）显式传递，没有被隐藏起来；
 * 只有在需要修改对象的时候，才必须用指针。它不是Go语言的约束，而是一种自然约束。

```
type Integer intfunc (a Integer) Less(b Integer) bool {    return a < b}
```

2. go语言是基于值语义的，传递的是值，而不是引用，所以才需要指针。
 * 需要注意的是，数组切片，map，channel，接口，并不是引用类型，只是在内部保存了相关的指针。
 * 未进行显式初始化的变量都会被初始化为该类型的零值。

3. Go语言中符号的可访问性是包一级的而不是类型一级的
 * 为以大写字母开头的符号都将被导出。

4. 接口查询，可以检查一个接口指向的对象实例是否实现了另一个接口。

```
var file1 Writer = ...
if file5, ok := file1.(two.IStream); ok {...}
```

类型查询，则可以直接查询接口指向的对象的类型`v := v1.(type)`。