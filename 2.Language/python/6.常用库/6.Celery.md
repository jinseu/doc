## celery

### AMQP

#### 基本概念

- Producer：发送消息方，一般用P表示。
- Queue:消息队列。相当于邮箱，本质上是一个无大小限制的缓冲区。消息队列可以接受多个生产者的消息，多个消费者也可以共享一个消息队列。
- Consumer:消费者。一个等待接收消息的程序。一般用C表示。
- Exchange：接收消息，转发消息到绑定的队列上，指定消息按什么规则，路由到哪个队列。
- Binding:绑定，它的作用就是把 Exchange 和 Queue 按照路由规则绑定起来。
- RoutingKey:路由关键字，Exchange 根据这个关键字进行消息投递。
- Channel:消息通道，在客户端的每个连接里可建立多个 Channel，每个 channel 代表一个会话。

exchange的类型：

1. Direct exchange 完全根据 key 进行投递，只有 key 与绑定时的 routing key 完全一致的消息才会收到消息
2. Fanount exchange 完全不关心 key，直接采取广播的方式进行消息投递，与该交换机绑定的所有队列都会收到消息
3. Topic exchange 会根据 key 进行模式匹配然后进行投递，与设置的 routing key 匹配上的队列才能收到消息
4. Header exchange 使用消息头代替 routing key 作为关键字进行路由，不过在实际应用过程中这种类型的 exchange 使用较少


在消息发送，并不是直接发送到queue，而是先发送到exchange，然后再由exchange发送到queue中。

RabbitMQ 支持消息的持久化，即将消息数据持久化到磁盘上，如果消息服务器中途断开，下次开启会将持久化的消息重新发送，消息队列持久化需要保证 exchange（指定 durable=1）、queue（指定 durable=1）和消息（delivery_mode=2）3 个部分都是持久化。

#### Topic

binding_key和routing key的形式一样。Topic exchange会将一个附带特定的routing key的消息将会被转发到与之匹配的binding key对应的队列中。需要注意的是：关于绑定键有两种特殊的情况:

`*`:可以匹配一个标识符。
`#`:可以匹配0个或多个标识符。

### kombu

### celery


#### 基本流程

1. 首先会初始化一个Celery对象app，设置broker和backend URL。同时会register_app到一个weakSet中


#### Consumer流程

1. 调用app.task 绑定任务。app.task是一个装饰器，会根据func生成一个PromiseProxy对象，完成任务绑定(延迟绑定，the act of creating the task is not performed until the task is used or the task registry is accessed），并返回。
2. 调用app.worker_main，启动worker(`celery.bin.worker:worker`)


#### Producer流程

1. 调用send_task发送任务

```
    def _task_from_fun(self, fun, name=None, base=None, bind=False, **options):
        if not self.finalized and not self.autofinalize:
            raise RuntimeError('Contract breach: app not finalized')
        name = name or self.gen_task_name(fun.__name__, fun.__module__)
        base = base or self.Task

        if name not in self._tasks:
            run = fun if bind else staticmethod(fun)
            task = type(fun.__name__, (base,), dict({
                'app': self,
                'name': name,
                'run': run,
                '_decorated': True,
                '__doc__': fun.__doc__,
                '__module__': fun.__module__,
                '__header__': staticmethod(head_from_fun(fun, bound=bind)),
                '__wrapped__': run}, **options))()
            # for some reason __qualname__ cannot be set in type()
            # so we have to set it here.
            try:
                task.__qualname__ = fun.__qualname__
            except AttributeError:
                pass
            self._tasks[task.name] = task
            task.bind(self)  # connects task to this app

            autoretry_for = tuple(options.get('autoretry_for', ()))
            retry_kwargs = options.get('retry_kwargs', {})

            if autoretry_for and not hasattr(task, '_orig_run'):

                @wraps(task.run)
                def run(*args, **kwargs):
                    try:
                        return task._orig_run(*args, **kwargs)
                    except autoretry_for as exc:
                        raise task.retry(exc=exc, **retry_kwargs)

                task._orig_run, task.run = task.run, run
        else:
            task = self._tasks[name]
        return task
```