## 函数

### 基本问题

#### 参数

在python中函数可以接收仍以数量的位置参数，可以使用一个`*`参数。

```
def avg(first, *rest):
    return (first + sum(rest)) / (1 + len(rest))
# Sample use
avg(1, 2) # 1.5
avg(1, 2, 3, 4) # 2.5

```
其中rest在函数内部是元组

同样，可以使用`*`把一个元组解开，以位置参数的形式传递给函数。

另外还可以使用`**`的形式，以字典的形式传递任意数量的参数。同样也可以使用`**`将字典解开，以关键字参数的形式传给给函数。

最后可以同时使用，`*`,`**` 使得一个函数，可以同时接受任意数量的位置参数和关键字参数。

**注意事项**

1. 一个* 参数只能出现在函数定义中最后一个位置参数后面，而**参数只能出现在最后一个参数。(这个地方的规定，python2和python3稍有不同，需要注意)
```
    def b(x, *args, **kwargs):
        pass

    # python2 ERROR
    def b(x, *args, y, **kwargs):
        pass
```
2. python2中不支持函数注解。

#### 返回值

python 表面上可以通过`,`分隔的形式返回多个值，但事实上是是先创建了一个元组然后返回的，这点需要注意。

#### 默认参数

定义一个有默认参数的函数是非常简单的，直接在函数定义中给参数指定一个默认值，并放到参数列表最后就行了。这一点和C++以及JAVA是相同的。

```
def spam(a, b=42):
    print(a, b)
```

在测试None 值时使用is 操作符是很重要的，也是这种方案的关键点。避免犯下下面这样的错误：
```
def spam(a, b=None):
    if not b: # NO! Use 'b is None' instead
    b = []
```

#### lambda 表达式

可以使用lambda表达式来定义函数。但是lambda的使用是有限制的。你只能指定单个表达式，它的值就是最后的返回值。也就是说不能包含其他的语言特性了，包括多个语句、条件表达式、迭代以及异常处理等等。例如

```
>>> add = lambda x, y: x + y
>>> add(2,3)
5
>>> add('hello', 'world')
'helloworld'
```

另外需要说明的是，lambda 表达式中的非参数变量，在运行时绑定值，而不是定义时就绑定，这跟函数的默认值参数定义是不同的。

如果你想让某个匿名函数在定义时就捕获到值，可以将那个参数值定义成默认参数即可。

```
>>> x = 10
>>> a = lambda y, x=x: x + y
>>> x = 20
>>> b = lambda y, x=x: x + y
>>> a(10)
20
>>> b(10)
30
```

另外还可以通过lambda定义一组函数

```
>>>funcs = [lambda x, n=n: x+n for n in range(5)]
>>>for f in funcs:
...    print(f(0))
0
1
2
3
4
```

#### functools

**partial**

partial函数在设置参数时，可以显示的指明是给哪个参数设置，如果没有显示说明，那么默认情况下从左往右依次设置。

```
>>> from functools import partial
>>> s1 = partial(spam, 1) # a = 1
>>> s1(2, 3, 4)
1 2 3 4
>>> s1(4, 5, 6)
1 4 5 6
>>> s2 = partial(spam, d=42) # d = 42
>>> s2(1, 2, 3)
1 2 3 42
>>> s2(4, 5, 5)
4 5 5 42
>>> s3 = partial(spam, 1, 2, d=42) # a = 1, b = 2, d = 42
>>> s3(3)
1 2 3 42
>>> s3(4)
1 2 4 42
>>> s3(5)
1 2 5 42
```

事实上，很多时候partial() 能实现的效果，lambda 表达式也能实现。

**wraps**

#### 闭包

闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。换句话说，这些函数可以“记忆”它被创建时候的环境。

在python2中并不支持在闭包内部对于外部变量值的改变，例如：

```
def sample():
    n = 10
    def add_n(value):
        print n + value
        #n = 100 
    return add_n

kk = sample()
kk(1)
```
如果不注释掉n=100这一行，那么n将被理解为本地变量，本地变量不允许在未赋值前访问。