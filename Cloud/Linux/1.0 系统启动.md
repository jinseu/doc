### 系统启动

Linux 操作系统的启动首先从 BIOS 开始，接下来进入 boot loader，由 bootloader 载入内核，进行内核初始化。内核初始化的最后一步就是启动 pid 为 1 的 init 进程。这个进程是系统的第一个进程。它负责产生其他所有用户进程。

init 以守护进程方式存在，是所有其他进程的祖先。

#### sysvinit

**系统启动顺序**

1. 启动BIOS，读取MBR（主引导记录），从MBR中获取GRUB地址，运行GRUB。
2. GRUB会加载kernel，并运行第一个程序/sbin/inittab来进行初始化工作。设定系统运行级别。根据系统运行的级别，运行对应的脚本/etc/init.d/rc 在rc脚本里会设置系统变量，网络，设定/proc,加载用户模块模块。
3. 根据runlevel启动对应的服务
4. 运行/etc/rc.local

**服务启动顺序**

确定服务启动的顺序是根据rc.d目录下的脚本确定的，该目录下都是符号链接，连接的是上层init.d目录下的服务脚本。在系统启动时会先运行K（kill）开头的脚本，然后运行S（start）开头的脚本。在运行同类的脚本时，先运行数字小的，然后运行数字大的。

**运行级**

linux中有7个运行级。包括

* `0：关机`
* `1：单用户模式`
* `2：多用户，无网络`
* `3：完全多用户`
* `4：保留未使用`
* `5：窗口模式，多用户，支持网络`
* `6：重启`

在/etc/inittab中定义了默认的runlevel，可以用runlevel查看当前和之前的runlevel，也可以用`telinit 3` 来改变当前runlevel，telinit会通过合适的信号来告诉init程序需要改变到什么模式下运行。

**单用户模式**

在单用户模式下，系统会运行/sbin/sulogin，一般用于系统故障时的维护，典型的场景有忘记root密码后，进入该模式修改root密码。


#### upstart

#### systemd

### 文件系统

#### 管理命令

##### find

命令格式

```
find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]
```

参数列表

1. `-name` 根据文件名进行查找
2. `-iname` 根据文件名进行查找，并忽略大小写
3. `-o`  表示条件之间是or关系
4. `-path` 匹配文件路径
5. `-regex` 根据正则表达式来匹配路径
6. `!`否定参数，例如`! -name ".txt"` 找到所有不以txt结尾的文件名
7. `-maxdepth` 最大递归深度
8. `-mindepth` 最小递归深度
9. `-atime {n} -mtime {n} -ctime {n}` 按照文件被读取或者执行的时间、文件内容修改时间、文件的i结点被修改的时间查找，n整数单位为天。-表示小于，+表示大于，无符号则表示恰好在该天修改的。
10. `-amin {n} -mmin {n} -cmin {n}` 按照修改时间查找，整数，单位为分钟
11. `-anewer -cnewer -newer` 按照访问时间找到比某个文件更新的文件
12. `-size` 按照大小查找 -表示小于，+表示大于，无符号则表示恰好这么大。可以使用的单位包括b,c,w,k,M,G
13. `-user`   按照文件所有权进行查找
14. `-exec`  可以对查询结果，执行其他命令。

#### 1. find能根据哪些条件来查找文件

文件名，文件权限，用户名，修改时间，访问时间（访问时间是文件最后一次被读取的时间），创建时间（文件元数据最后一次被更改的时间），类型，大小，目录的深度，inode

常见的type有 b（块文件） d（目录） c（字符文件） p（管道文件） l（链接） f（普通文件） s（socket文件）

#### 2. find能否根据文件内容来检索

不可以，本身只是根据文件的属性进行查找的

#### 3. find删除找到的文件的

    删除查找到的文件
    find . -name "*.md" -delete
    find . -name "*.dump" | xargs rm -f
    find . -type f -name "*.dump" -exec rm -f '{}' \;
    #查找后缀为txt或pdf的文件
    find . \( -name "*.txt" -o -name "*.pdf"\)
    #找到比file.txt更新的文件
    find . -type f -newer file.txt
    #跳过指定的目录
    find . \( -name ".git" -prune \) -o \( -type f \)

#### 4. find找到目录的最大深度

```
find /home/kiva/cephfs/var/ -type d -printf '%d %p\n' | sort -rn | head -1
```

### 转换文件目录编码

convmv -f 源编码 -t 新编码 [选项] 文件名

常用参数：

```
-r 递归处理子文件夹
--notest 真正进行操作，请注意在默认情况下是不对文件进行真实操作的，而只是试验。
--list 显示所有支持的编码
--unescap 可以做一下转义，比如把%20变成空格
```

样例

```
convmv -f UTF-8 -t GBK -r --notest ./var
```%
