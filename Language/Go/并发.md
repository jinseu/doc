## 并发

在1.5 版本之后，golang运行时默认会为每个可用的物理处理器分配一个逻辑处理器。在1.5 版本之前的版本中，默认给整个应用程序只分配一个逻辑处理器。这些逻辑处理器会用于执行所有被创建的goroutine。

可以调用runtime包的GOMAXPROCS函数来设置逻辑处理器的数量。

一个逻辑处理器对应着内核中的一个线程。

### 协程 Goroutine

基本概念：
1. G Goroutine 即Go语言协程，Goroutine的创建，销毁，停止都收到go语言运行时的管理
2. M Machine 即系统线程。M会从运行队列中取出G，然后运行G到完毕或者进入休眠状态。在阻塞时会释放P
3. P Process 即GOMAXPROCS 函数设置的逻辑处理器数量。同一时间只有一个线程拥有P。

#### Goroutine基本并发原则

1. 一个模块p中导入了一个模块q，那么q的init函数执行一定会在p的init函数之前。
2. main函数将在所有的init函数执行完毕之后再执行。
3. 在goroutine 创建之前的语句，即`go`语句之前的语句，一定保证happen before go routine中的语句。

### goroutine

一个goroutine在执行时，对应着一个逻辑处理器，然后在goroutine执行I/O等操作阻塞时或者运行时认为需要调度时，运行时调度器会选择另一个就绪的goroutine来继续执行。

可以显示调用runtime.Gosched() 将当前 goroutine 从线程退出，并放回到队列。

### channel

#### 创建channel

```
// 无缓冲的整型通道unbuffered := make(chan int)// 有缓冲的字符串通道buffered := make(chan string, 10)
```

#### 读写channel

在从通道接收数据或者向通道发送数据时，使用的操作符`<-`

```
// 通过通道发送一个字符串buffered <- "Gopher"
// 从通道接收一个字符串value := <-buffered
```

chan读写数据并不是异步的，而是同步的，也就是说，在数据没有准备好的时候阻塞。

#### 单向channel

channel默认情况是双向的，可以读，可以写，但是在channel 实例在定义时可以指定方向，将channel变为一个单向channel。

```
timeout <-chan time.Time \\ 说明只会从timeout中读取数据，但是不会写入数据
```

单向channel的使用一般在函数的定义中，限制函数中对channel的读写。

```
func Notify(c chan<- os.Signal, sig ...os.Signal)
```

### sync 包

#### Cond

Cond 在一个lock的基础上，实现cond 变量，可以通过wait来等待事件的发生，也可以通过Broadcast，signal来唤醒goroutine。需要注意的是，signal 允许不持有c.L。

```
 func NewCond(l Locker) *Cond
 func (c *Cond) Broadcast()
 func (c *Cond) Signal()
 func (c *Cond) Wait()
```


#### Locker

```
type Locker interface {
    Lock()
    Unlock()
}
```

#### Mutex

mutex 互斥锁，有两个方法，分别为Lock()和Unlock()。其中在获取不到锁的时候，Lock方法会一直阻塞。

#### Map

Goland 中 concurrent map实现。包括一下方法

1. Load 
2. Store 
3. LoadOrStore
4. Range
5. Delete

LoadOrStore 方法会尝试从map中查找对应的key，如果找不到，则会将key，value放入map中

Range 方法的参数是一个函数f，会对map中的每一对key，value 调用函数f，直到f返回false，才会停止。Range函数并不是针对map的snapshot，Range只保证no key will be visited more than once。

#### Pool

Pool是一块缓存，用来保存目前已经分配但是没有使用的数据，可以安全的供多个goroutines使用。有两个方法，分别为Get，Put。Pool本质上类似于JAVA中的ThreadLocal变量。

#### RWMutex

读写锁，有以下方法：

1. func (rw *RWMutex) Lock()
2. func (rw *RWMutex) RLock()
3. func (rw *RWMutex) RLocker() Locker 获取一个RLocker，Lock 和 Unlock 方法分别对应rw.RLock 和 rw.RUnlock.
4. func (rw *RWMutex) RUnlock()
5. func (rw *RWMutex) Unlock()

#### WaitGroup


WaitGroup 有点类似于信号量，其内部保存一个counter值，可以对counter值进行add操作，然后每调用done一次，counter值减一。

**1. Add(delta int)**

counter值加delta，如果counter值为负，那么add操作将panic

**2. Done()**

counter值减去1

**3. Wait()**

阻塞，直到counter等于0

#### sync/atomic

sync/atomic 包中提供了了一系列的原子函数，可以分为以下四类

**1. 读取**

原子性的读取变量的值，保证在读取变量的时候，任何其他CPU都无法对该变量进行读写。具体的包括
以下函数

- func LoadInt32(addr *int32) (val int32)
- func LoadInt64(addr *int64) (val int64)
- func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)
- func LoadUint32(addr *uint32) (val uint32)
- func LoadUint64(addr *uint64) (val uint64)
- func LoadUintptr(addr *uintptr) (val uintptr)

**2. 存储**

原子性的写变量的值，保证在写变量时，其他CPU都无法对该变量进行读写。支持的数据类型和Load函数类似。形式如下

func StoreInt32(addr *int32, val int32)

**3. add**

原子性的增加或减少(delta 值为负）变量的值。并返回新的值。支持的数据类型和Load函数类似。形式如下

func AddInt32(addr *int32, delta int32) (new int32)


**3. CAS(Compare And Swap)**

原子性CAS操作，比较`*addr == old`，如果等于，则`*addr = new`。支持的数据类型和Load函数类似。形式如下

func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)

**4. Swap**

swap 系列函数则更为简单，原子性将新值赋予旧值，并返回旧值。支持的数据类型和Load函数类似。形式如下

func SwapInt32(addr *int32, new int32) (old int32)
