**3模板**
     首先我们需要说明的是C++中的模板和JAVA中的接口，泛型是完全不同的。模板的定义只有在其被对应的类型实例化时，才会产生一个对应类，是编译时的动作。对于模板中的静态对象，我们必须显示指定类型，才能使用静态对象。
但是对于模板类中未经使用的成员函数而言，C++标准要求只有在成员函数被使用的时候，才会“实例化”。这样做，主要是基于空间和时间的考虑。如果有100个成员函数，但是程序中只会针对特定类型使用两个，那么其他的函数都实例化，会花费大量的时间。另一个方面也是为了安全，因为一个模板实例化的类型可能并不能完整的支持所有运算符，全部实例化，可能导致错误。
目前来说，成员函数的实例化，主要是在两个阶段，第一：编译阶段。第二：链接阶段。在具体实现时有三个问题需要解决。
1.	编译器如何找出函数的定义
Template program text file
要求文件有统一的命名规则。
2.	编译器如何能够只实例化程序中用到的member function
忽略这项要求
模拟链接操作
3.	编译器如何阻止在多个目标文件中被实例化
产生多个实例实例，在链接器中予以甄别
模拟链接操作
还有一种问题是在int和long一致的架构中，Point<int> pi; Point<long> pi是否需要产生两个实例，答案是未知的，需要依赖于编译器具体的实现。
另外在模板中还涉及一个名称决议的问题。不同的实例化类型可能对应不同函数。
3.2	异常处理
异常处理中最重要的工作就是找出catch子句，以处理被抛出来的exception。同时，编译器还需要知道被抛出对象的类型，以及管理被抛出对象的析构。
当一个exception被抛出来，但是没有一个对应的catch语句时，那么默认的处理程序terminate会被调用。在异常抛出的同时会面临一个堆栈退出的操作，于是乎，就需要析构本地变量，释放锁，同时将异常抛出。
所以在程序抛出异常的时候一定需要特别注意。此外还涉及到new操作抛出异常，以及构造函数抛出异常。
一般而言，当一个exception发生时，需要完成以下事情。

1.	校验发生throw操作的函数
2.	决定throw操作是否发生在try区段中
3.	若是，编译系统必须把exception type拿来和每一个catch子句进行比较。
4.	如果比较厚吻合，流程控制应该交到catch子句中
5.	如果throw的发生不在try区段中，或没有catch子句吻合，那么系统必须摧毁所有的local object，退栈，将程序退到上一个函数中去，然后重复以上过程。

所以，对于每一个被抛出来的exception，编译器都必须产生一个类型描述器，来对exception的类型信息进行编码，同时对于派生类而言还需要保存基类的信息。
另外在catch的时候还面临一个问题，就是引用和值的区别。
事实上，为了支持异常，C++付出了非常大的代价，不论是在运行时的内存占用还是执行速度，都有了相当大的损失。
3.3	RTTI(运行时类型识别)
由于C++并不支持安全的向下转换操作，而要想支持这一点，首先需要额外的空间以存储类型信息，此外还需要额外的时间以决定执行器的类型。
于是乎在C++中有dynamic_cast运算符，来支持真正的安全动态转换。为了支持这个操作符，C++引入了type_info类，来描述类型，这个类中包含着类型信息。C++对象的virtual table中内含一个type_info object 地址
