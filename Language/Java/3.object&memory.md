
### JAVA 内存

#### 1.1 JAVA内存区域

**1.程序计数器**
**2.JAVA虚拟机栈**

-Xss

**3.本地方法栈**

**4.JAVA堆**

-Xms20m –Xmx20m
将最小值和最大值设为一样，即可避免堆的自动扩展。

**5.方法区**

包括类信息，编译后的代码以及运行时常量池
-XX：MaxPermSize=10M
**6.直接内存**

#### 1.2 JAVA 对象的内存布局

在hotspot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头，实例数据和对齐填充。
对象头信息分为两个部分，第一部分用于存储对象自身的运行时数据，如hashcode，GC分代年龄，锁状态标识，线程持有的锁，偏向线程ID、偏向时间戳等，另一部分则是类型指针，即对象指向他的类元数据的指针，虚拟机可以通过这个指针来确定这个对象是哪个类的实例。此外当对象是一个数组的时候，对象头中还必须有一块用于记录数组长度的数据。
对齐填充并不是必然存在的，也没有特别的含义，仅仅是一个占位符的作用。和C++结构体的对齐方式是类似的。
对象的访问定位

**1.使用句柄方位**

在JAVA堆中划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄地址中包含了对象的实例数据与类型数据各自的具体地址。

**2.直接指针访问**

Reference中存放的就是对象地址，而在每个对象中存储了一个指向对象类型的数据。
使用句柄的方式好处是reference存放的是稳定的句柄地址，在对象呗移动的时候，只需改变句柄中的实例指针即可。但是却增加了依次指针定位的开销。就hotspot而言是采用第二种方式的。



#### 1.3 JAVA泛型

**1.JAVA内存收集算法**

**2.C++对象**





### 反射

#### 代理

> https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/
> 
> https://www.ibm.com/developerworks/cn/java/coretech/java-dynamic.html